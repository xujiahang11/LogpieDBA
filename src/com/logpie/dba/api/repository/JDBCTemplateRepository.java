package com.logpie.dba.api.repository;


import com.logpie.dba.api.annotation.AutoGenerate;
import com.logpie.dba.api.annotation.Column;
import com.logpie.dba.api.annotation.ID;
import com.logpie.dba.api.basic.*;
import com.logpie.dba.support.Assert;
import com.logpie.dba.support.ReflectionUtil;
import com.logpie.dba.support.SqlUtil;
import com.logpie.dba.support.TableUtil;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.PreparedStatementCreator;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;

import java.lang.reflect.Field;
import java.math.BigInteger;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.List;
import java.util.logging.Logger;

public abstract class JDBCTemplateRepository<T extends Model> implements
		SimpleRepository<T, Number>, PagingAndSortingRepository<T, Number> {

	private static final String CLASSNAME = JDBCTemplateRepository.class.getName();
	private static final Logger LOG = Logger.getLogger(CLASSNAME);

	@Autowired
	private JdbcTemplate jdbcTemplate;

	private Class<T> c;
	private RowMapper<T> rowMapper;

	/**
	 * initiate repository
	 * 
	 * @param c model class
	 */
	public JDBCTemplateRepository(Class<T> c) {
		this.c = c;
		rowMapper = (RowMapper<T>) ReflectionUtil.buildInstanceByDefaultConstructor(c);
	}

	@Override
	public T insert(T model) {
		String sql = SqlUtil.insertSQL(model);
		if (sql == null) return null;

		PreparedStatementCreator psc = new PreparedStatementCreator() {
			public PreparedStatement createPreparedStatement(
					Connection connection) throws SQLException {
				return connection.prepareStatement(sql, PreparedStatement.RETURN_GENERATED_KEYS);
			}
		};

		KeyHolder holder = new GeneratedKeyHolder();
		jdbcTemplate.update(psc, holder);

		// If id is auto generated, we will backfill the id.
		// For other auto-generated fields, we won't backfill for now.
		return buildModelWithAutoGeneratedIdIfNecessary(model, holder);
	}

	T buildModelWithAutoGeneratedIdIfNecessary(T model, KeyHolder holder) {
		final FieldWrapper idWrapper = getIdFieldWrapper(model);
		if (idWrapper.isAutoGenerated()) {
			final Number idNumber = holder.getKey();
			Assert.notNull(idNumber, "Auto-generating ID is failed. ID's value is null");

			final Column.DataType idDataType = idWrapper.getType();
			Assert.notNull(idDataType, "The data type of ID with @Column is missing");

			final Field idField = idWrapper.getField();

			switch (idDataType) {
				case BIGINT: {
					ReflectionUtil.runSetter(idField, model, idDataType.toJavaClass(), BigInteger.valueOf(idNumber.longValue()));
					break;
				}
				case LONG: {
					ReflectionUtil.runSetter(idField, model, idDataType.toJavaClass(), idNumber.longValue());
					break;
				}
				case INTEGER: {
					ReflectionUtil.runSetter(idField, model, idDataType.toJavaClass(), idNumber.intValue());
					break;
				}
				default: {
                    LOG.severe("ID with @AutoGenerate must use either BigInteger or Long or Integer as DataType");
                    throw new RuntimeException();
				}
			}
		}
		return model;
	}

    private FieldWrapper getIdFieldWrapper(T model) {
        final Class clazz = model.getClass();
        FieldWrapper idWrapper = new FieldWrapper();
        for (final Field field : clazz.getDeclaredFields())
        {
            final ID id = field.getAnnotation(ID.class);
            final Column column = field.getAnnotation(Column.class);
            if (id != null)
            {
                idWrapper.setType(column.type());
                idWrapper.setField(field);
            }
        }
        if (idWrapper.getType() == null || idWrapper.getField() == null)
        {
            LOG.severe("@ID can't be null in " + clazz.getName());
            throw new RuntimeException();
        }
        return idWrapper;
    }

	@Override
	public void update(T model) {
		jdbcTemplate.execute(SqlUtil.updateSQL(model));
	}

	@Override
	public T queryOne(Number primaryKey) {
		String sql = SqlUtil.queryAllSQL(c);
		Parameter param = new WhereParam(c, TableUtil.getId(c), primaryKey);
		sql += SqlUtil.whereSQL(c, param);
		return jdbcTemplate.queryForObject(sql, rowMapper);
	}

	@Override
	public Iterable<T> queryAll() {
		return jdbcTemplate.query(SqlUtil.queryAllSQL(c), rowMapper);
	}

	@Override
	public Page<T> queryAll(Pageable pageable) {
		Assert.notNull(pageable, "Paging information must not be null");

		String sql = SqlUtil.queryBySQL(c, pageable);
		List<T> contents = jdbcTemplate.query(sql, rowMapper);

		return new SimplePage<>(pageable, contents, count());
	}

	@Override
	public Iterable<T> queryBy(Parameter... params) {
		String sql = SqlUtil.queryBySQL(c, params);
		if (sql == null) {
			return null;
		}
		return jdbcTemplate.query(sql, rowMapper);
	}

	@Override
	public Page<T> queryBy(Pageable pageable, Parameter... params) {
		Assert.notNull(pageable, "Paging information must not be null");
		Assert.notNull(params, "Parameter must not be null");

		String sql = SqlUtil.queryBySQL(c, pageable, params);
		System.out.println("SQL --- " + sql);
		List<T> contents = jdbcTemplate.query(sql, rowMapper);

		return new SimplePage<>(pageable, contents, count());
	}

	@Override
	public boolean exists(Number primaryKey) {
		return queryOne(primaryKey) == null;
	}

	@Override
	public int count() {
		String sql = SqlUtil.countSQL(c, null);
		return jdbcTemplate.queryForObject(sql, Integer.class);
	}

	@Override
	public void delete(T model) {
		// TODO Auto-generated method stub

	}

	public Iterable<T> query(String sql) {
		if (sql == null || sql.isEmpty()) {
			return null;
		}
		return jdbcTemplate.query(sql, rowMapper);
	}

	class FieldWrapper {

		private Column.DataType type;
		private Field field;

		public Column.DataType getType() {
			return type;
		}

		public void setType(Column.DataType type) {
			this.type = type;
		}

		public Field getField() {
			return field;
		}

		public void setField(Field field) {
			this.field = field;
		}

		boolean isAutoGenerated() {
			if(field != null) {
				final AutoGenerate autoGenerateAnnotation = field.getAnnotation(AutoGenerate.class);
				if(autoGenerateAnnotation != null)
					return true;
			}
			return false;
		}
	}
}

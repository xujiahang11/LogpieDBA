package com.logpie.dba.core;


import com.logpie.dba.annotation.Column;
import com.logpie.dba.annotation.AutoGenerate;
import com.logpie.dba.annotation.ID;
import com.logpie.dba.dao.*;
import com.logpie.dba.dao.SimpleCondition;
import com.logpie.dba.support.Assert;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.PreparedStatementCreator;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;

import java.lang.reflect.Field;
import java.math.BigInteger;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.List;
import java.util.logging.Logger;

public abstract class JDBCTemplateRepository<T extends Model> implements SimpleRepository<T, Number>, PagingAndSortingRepository<T, Number> {

    private static final String CLASSNAME = JDBCTemplateRepository.class.getName();
    private static final Logger LOG = Logger.getLogger(CLASSNAME);

    @Autowired
    private JdbcTemplate jdbcTemplate;

    private Class<T> c;
    private RowMapper<T> rowMapper;

    /**
     * initiate repository
     *
     * @param c model class
     */
    public JDBCTemplateRepository(Class<T> c)
    {
        this.c = c;
        rowMapper = (RowMapper<T>) ReflectionUtil.buildInstanceByDefaultConstructor(c);
    }

    @Override
    public T insert(T model)
    {
        String sql = SQLEngine.insertSQL(model);
        if (sql == null)
            return null;

        PreparedStatementCreator psc = new PreparedStatementCreator() {
            public PreparedStatement createPreparedStatement(Connection connection) throws SQLException
            {
                return connection.prepareStatement(sql, PreparedStatement.RETURN_GENERATED_KEYS);
            }
        };

        KeyHolder holder = new GeneratedKeyHolder();
        jdbcTemplate.update(psc, holder);

        // If id is auto generated, we will backfill the id.
        // For other auto-generated fields, we won't backfill for now.
        return buildModelWithAutoGeneratedIdIfNecessary(model, holder);
    }

    T buildModelWithAutoGeneratedIdIfNecessary(T model, KeyHolder holder)
    {
        final FieldWrapper idWrapper = getIdFieldWrapper(model);
        if (idWrapper.isAutoGenerated())
        {
            final Number idNumber = holder.getKey();
            Assert.notNull(idNumber, "Auto-generating ID is failed. ID's value is null");

            final Column.DataType idDataType = idWrapper.getType();
            Assert.notNull(idDataType, "The data type of ID with @Column is missing");

            final Field idField = idWrapper.getField();

            switch (idDataType)
            {
                case BIGINT:
                {
                    ReflectionUtil.runSetter(idField, model, idDataType.toJavaClass(), BigInteger.valueOf(idNumber.longValue()));
                    break;
                }
                case LONG:
                {
                    ReflectionUtil.runSetter(idField, model, idDataType.toJavaClass(), idNumber.longValue());
                    break;
                }
                case INTEGER:
                {
                    ReflectionUtil.runSetter(idField, model, idDataType.toJavaClass(), idNumber.intValue());
                    break;
                }
                default:
                {
                    LOG.severe("ID with @AutoGenerate must use either BigInteger or Long or Integer as DataType");
                    throw new RuntimeException();
                }
            }
        }
        return model;
    }

    private FieldWrapper getIdFieldWrapper(T model)
    {
        final Class clazz = model.getClass();
        FieldWrapper idWrapper = new FieldWrapper();
        for (final Field field : clazz.getDeclaredFields())
        {
            final ID id = field.getAnnotation(ID.class);
            final Column column = field.getAnnotation(Column.class);
            if (id != null)
            {
                idWrapper.setType(column.type());
                idWrapper.setField(field);
            }
        }
        if (idWrapper.getType() == null || idWrapper.getField() == null)
        {
            LOG.severe("@ID can't be null in " + clazz.getName());
            throw new RuntimeException();
        }
        return idWrapper;
    }

    @Override
    public void update(T model)
    {
        jdbcTemplate.execute(SQLEngine.updateSQL(model));
    }

    @Override
    public T queryOne(Number primaryKey)
    {
        String sql = SQLEngine.queryAllSQL(c);

        Clause clause = new Clause.Equal(c, TableUtils.getIdLabel(c), primaryKey);
        sql += SQLEngine.whereSQL(c, new SimpleCondition(clause));

        return jdbcTemplate.queryForObject(sql, rowMapper);
    }

    @Override
    public Iterable<T> queryAll()
    {
        return jdbcTemplate.query(SQLEngine.queryAllSQL(c), rowMapper);
    }

    @Override
    public Page<T> queryAll(Pageable pageable)
    {
        Assert.notNull(pageable, "Paging information must not be null");

        String sql = SQLEngine.queryBySQL(c, pageable, null);
        List<T> contents = jdbcTemplate.query(sql, rowMapper);

        return new SimplePage<>(pageable, contents, count());
    }

    public Iterable<T> queryBy(Condition condition)
    {
        String sql = SQLEngine.queryBySQL(c, condition);
        return sql == null ? null : jdbcTemplate.query(sql, rowMapper);
    }

    @Override
    public Page<T> queryBy(Pageable pageable, Condition condition)
    {
        Assert.notNull(pageable, "Paging information must not be null");
        Assert.notNull(condition, "SimpleCondition must not be null");

        String sql = SQLEngine.queryBySQL(c, pageable, condition);
        List<T> contents = jdbcTemplate.query(sql, rowMapper);

        return new SimplePage<>(pageable, contents, count());
    }

    @Override
    public boolean exists(Number primaryKey)
    {
        return queryOne(primaryKey) == null;
    }

    @Override
    public int count()
    {
        /*
		String sql = SQLEngine.countSQL(c, null);
		return jdbcTemplate.queryForObject(sql, Integer.class);
		*/
        return 0;
    }

    @Override
    public void delete(T model)
    {
        // TODO Auto-generated method stub

    }

    public Iterable<T> query(String sql)
    {
        if (sql == null || sql.isEmpty())
        {
            return null;
        }
        return jdbcTemplate.query(sql, rowMapper);
    }

    class FieldWrapper {

        private Column.DataType type;
        private Field field;

        public Column.DataType getType()
        {
            return type;
        }

        public void setType(Column.DataType type)
        {
            this.type = type;
        }

        public Field getField()
        {
            return field;
        }

        public void setField(Field field)
        {
            this.field = field;
        }

        boolean isAutoGenerated()
        {
            if (field != null)
            {
                final AutoGenerate autoGenerateAnnotation = field.getAnnotation(AutoGenerate.class);
                if (autoGenerateAnnotation != null)
                    return true;
            }
            return false;
        }
    }
}

package com.logpie.dba.core;

import com.logpie.dba.annotation.*;

import java.lang.reflect.Field;
import java.util.*;
import java.util.logging.Level;
import java.util.logging.Logger;

class TableUtils {

    private static final String CLASS_NAME = TableUtils.class.getName();
    private static final Logger LOG = Logger.getLogger(CLASS_NAME);

    /**
     * Generate a Table object of model c by using reflection. The nested referenced tables without customized alias will auto-generated one.
     *
     * @param c     model class
     * @param alias customized alias for this table
     * @return a Table object with customized alias or auto-generated alias
     */
    static Table build(final Class<?> c, final String alias)
    {
        String name = getTableName(c);
        Field idField = getIdField(c);
        List<Field> columns = getColumnFields(c);

        Map<String, Table> referencedTableMapping = new HashMap<>();
        for (Field field : getReferencedColumnFields(c))
        {
            // Generate a referenced table
            ReferencedColumn refColumn = field.getAnnotation(ReferencedColumn.class);
            Class<?> refClass = refColumn.referencedEntityClass();
            String refAlias = refColumn.referencedEntityAlias();
            Table refTable = build(refClass, refAlias);

            // Set an auto-generated alias if this table doesn't have one
            // MUST CONSTRUCT THE TABLE BEFORE SET AN AUTO ALIAS, otherwise this alias will be passed to nested building process
            if(refAlias.equals(""))
            {
                String tableNameOrAliasIfExisted = alias == null || alias.equals("") ? name : alias;
                String autoGeneratedRefAlias = getAutoGeneratedRefAlias(tableNameOrAliasIfExisted, refColumn);
                refTable.setAlias(autoGeneratedRefAlias);
            }

            Column column = field.getAnnotation(Column.class);
            referencedTableMapping.put(column.label(), refTable);
        }

        return new Table(c, name, alias, idField, columns, referencedTableMapping);
    }

    /**
     * Get name of table c
     *
     * @param c model class
     * @return table name or null
     */
    static String getTableName(final Class<?> c)
    {
        if (c.isAnnotationPresent(Entity.class))
        {
            Entity entity = c.getAnnotation(Entity.class);
            return entity.table();
        }
        LOG.log(Level.WARNING, "Cannot find any table. Please make sure to add @Entity annotation to your model class");
        return null;
    }

    /**
     * Get id field of table c. @ID column should be primary key of this table
     *
     * @param c model class
     * @return id field or null. If there are multiple ids, the first one will be returned
     */
    static Field getIdField(final Class<?> c)
    {
        Field idField = null;
        Field[] fields = c.getDeclaredFields();

        for (Field field : fields)
        {
            if (field.isAnnotationPresent(ID.class) && field.isAnnotationPresent(Column.class))
            {
                if (idField == null)
                {
                    idField = field;
                } else
                {
                    LOG.log(Level.WARNING, "Found multiple ids. @ID should be unique");
                    return idField;
                }
            }
        }

        if (idField == null)
        {
            LOG.log(Level.WARNING, "Cannot find any id from this class. Please make sure to add @ID & @Column annotation to a field");
        }
        return idField;
    }

    /**
     * Generate an alias automatically for a referenced table
     * <p>
     * Auto-generated Alias Format
     * <p>
     * If the current table has an alias, use current_table_alias +
     * referenced_table_name, otherwise use current_table_name +
     * referenced_table_name;
     * <p>
     * e.g "OrderShop" means an alias for table 'Shop' which is referred by table 'Order'
     *
     * @param tableNameOrAliasIfExisted current table's name or alias if existed
     * @param referencedColumn          a foreign key in this table
     * @return an auto-generated alias for the referenced table
     */
    private static String getAutoGeneratedRefAlias(final String tableNameOrAliasIfExisted, final ReferencedColumn referencedColumn)
    {
        String referencedTableName = getTableName(referencedColumn.referencedEntityClass());
        return tableNameOrAliasIfExisted + referencedTableName;
    }

    /**
     * Get fields which has @Column and @ReferencedColumn annotations in table c
     *
     * @param c model class
     * @return a List of fields which has @ReferencedColumn annotation
     */
    private static List<Field> getReferencedColumnFields(final Class<?> c)
    {
        List<Field> foreignFields = new ArrayList<>();
        for (Field field : getColumnFields(c))
        {
            if (field.isAnnotationPresent(ReferencedColumn.class))
            {
                foreignFields.add(field);
            }
        }
        return foreignFields;
    }

    /**
     * Get fields which has @Column and @ReferencedColumn annotations in table c
     *
     * @param c model class
     * @return a List of fields which has @Column annotation
     */
    private static List<Field> getColumnFields(final Class<?> c)
    {
        List<Field> columnFields = new ArrayList<>();
        Field[] fields = c.getDeclaredFields();
        for (Field field : fields)
        {
            if (field.isAnnotationPresent(Column.class))
            {
                columnFields.add(field);
            }
        }
        return columnFields;
    }
}
